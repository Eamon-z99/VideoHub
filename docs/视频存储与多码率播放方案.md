# 视频存储与多码率播放完整方案

> 基于 B站 DASH 架构的规范化视频处理与播放方案

---

## 一、整体架构流程

```
用户上传 → 原始文件存储 → 转码任务队列 → 多清晰度转码 → 分片存储 → Manifest生成 → 播放接口 → MSE播放器
```

---

## 二、技术栈总览

### 2.1 上传层

| 组件 | 技术选型 | 说明 |
|------|---------|------|
| **前端上传** | `axios` / `fetch` + `FormData` | 基础文件上传 |
| **分块上传** | 云存储 SDK（OSS/COS/S3）的 `multipart upload` | 大文件断点续传 |
| **上传进度** | `XMLHttpRequest.onprogress` / `fetch` + `ReadableStream` | 实时进度反馈 |
| **文件校验** | `MD5` / `SHA256` | 上传前后完整性校验 |

**推荐方案：**
- **云存储**：阿里云 OSS、腾讯云 COS、AWS S3（支持 multipart upload）
- **本地存储**：直接写入本地文件系统（Windows/Linux）

---

### 2.2 媒体处理层（转码 + 分片）

| 组件 | 技术选型 | 说明 |
|------|---------|------|
| **转码引擎** | `FFmpeg`（命令行 / `libavcodec` / `libavformat`） | 视频转码、编码、封装 |
| **任务队列** | `RabbitMQ` / `Redis Queue` / `Kafka` / `数据库轮询` | 异步任务调度 |
| **任务调度** | `Spring Boot @Async` / `Celery` / `Kubernetes Jobs` | 后台任务执行 |
| **多清晰度配置** | FFmpeg 预设文件（`.ffpreset`）或配置文件 | 统一码率/分辨率策略 |
| **分片算法** | FFmpeg `-f segment` / `-segment_time` | 按时间切分 fMP4 |
| **元数据提取** | `ffprobe` / `mediainfo` | 获取分辨率、码率、时长等 |

**FFmpeg 关键命令示例：**
```bash
# 多清晰度转码（并行）
ffmpeg -i input.mp4 \
  -map 0:v:0 -map 0:a:0 \
  -c:v libx264 -preset medium -crf 23 -maxrate 2M -bufsize 4M \
  -c:a aac -b:a 128k \
  -s 1280x720 -r 30 \
  output_720p.mp4

# fMP4 分片（DASH 格式）
ffmpeg -i input.mp4 \
  -map 0:v -map 0:a \
  -c:v copy -c:a copy \
  -f dash \
  -seg_duration 4 \
  -init_seg_name init-$RepresentationID$.m4s \
  -media_seg_name seg-$RepresentationID$-$Number$.m4s \
  manifest.mpd
```

**推荐方案：**
- **开发/小规模**：Spring Boot + FFmpeg 命令行（`ProcessBuilder`）
- **生产环境**：FFmpeg + FFmpeg-python + Celery（Python）或 Kubernetes Jobs（容器化）

---

### 2.3 存储层

| 组件 | 技术选型 | 说明 |
|------|---------|------|
| **对象存储** | 阿里云 OSS / 腾讯云 COS / AWS S3 / MinIO | 云存储服务 |
| **本地存储** | 文件系统（NTFS/ext4） | 本地大容量硬盘 |
| **CDN 分发** | 阿里云 CDN / 腾讯云 CDN / CloudFlare | 加速分片文件访问 |
| **存储结构** | 目录树 + 命名规范 | 清晰度/轨道分离存储 |

**存储目录结构示例：**
```
/videos/{cid}/
  ├─ manifest.json              # 播放清单（类似 B站 playurl）
  ├─ video_1080p/
  │   ├─ init.m4s               # 初始化段
  │   ├─ seg-0001.m4s
  │   ├─ seg-0002.m4s
  │   └─ ...
  ├─ video_720p/
  │   └─ ...
  ├─ audio_128k/
  │   └─ ...
  └─ audio_192k/
      └─ ...
```

**推荐方案：**
- **云环境**：OSS/COS + CDN（自动分发）
- **本地环境**：E盘大容量存储 + Nginx 静态文件服务

---

### 2.4 清单层（Manifest / Playurl）

| 组件 | 技术选型 | 说明 |
|------|---------|------|
| **清单格式** | DASH MPD（XML）/ HLS m3u8 / **自定义 JSON** | 描述分片信息 |
| **清单生成** | 后端服务动态生成 / 转码后静态生成 | 根据存储结构生成 |
| **清单存储** | 数据库（MySQL/PostgreSQL）+ 文件系统 | 元数据 + 文件路径 |

**Manifest JSON 结构（参考 B站 playurl）：**
```json
{
  "cid": "33095614562",
  "duration": 212,
  "accept_quality": [112, 80, 64, 32, 16],
  "dash": {
    "duration": 212,
    "minBufferTime": 1.5,
    "video": [
      {
        "id": 80,
        "baseUrl": "/mse/33095614562/video_1080p/seg-0001.m4s",
        "mimeType": "video/mp4",
        "codecs": "avc1.640033",
        "width": 1920,
        "height": 1080,
        "bandwidth": 2000000,
        "SegmentBase": {
          "Initialization": "0-947",
          "indexRange": "948-1495"
        }
      }
    ],
    "audio": [
      {
        "id": 30280,
        "baseUrl": "/mse/33095614562/audio_128k/seg-0001.m4s",
        "mimeType": "audio/mp4",
        "codecs": "mp4a.40.2",
        "bandwidth": 128000
      }
    ]
  }
}
```

**推荐方案：**
- **后端接口**：Spring Boot REST API（`/api/playurl/{cid}`）
- **清单生成**：转码完成后自动生成并写入数据库/文件

---

### 2.5 播放层（前端）

| 组件 | 技术选型 | 说明 |
|------|---------|------|
| **播放协议** | DASH（MPEG-DASH） | 多清晰度自适应流 |
| **浏览器 API** | **Media Source Extensions (MSE)** | 手动拼接音视频流 |
| **播放器库** | `dash.js` / `hls.js` / **自研 MSE 播放器** | 封装 MSE 逻辑 |
| **HTTP 请求** | `fetch` / `axios` | 拉取分片文件 |
| **音视频同步** | MSE `SourceBuffer` + `appendBuffer` | 时间戳对齐 |
| **清晰度切换** | 切换 `video` 轨的 `baseUrl` + 重新 append | 动态切换码率 |
| **拖动支持** | 根据 `currentTime` 计算 segment index | 按需加载分片 |

**MSE 播放器核心代码结构：**
```javascript
// 1. 创建 MediaSource
const mediaSource = new MediaSource()
video.src = URL.createObjectURL(mediaSource)

// 2. 创建 SourceBuffer（视频 + 音频）
mediaSource.addEventListener('sourceopen', () => {
  const videoSb = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.640033"')
  const audioSb = mediaSource.addSourceBuffer('audio/mp4; codecs="mp4a.40.2"')
  
  // 3. 按顺序 fetch + appendBuffer
  fetch(manifest.video[0].baseUrl)
    .then(res => res.arrayBuffer())
    .then(buf => videoSb.appendBuffer(buf))
  
  fetch(manifest.audio[0].baseUrl)
    .then(res => res.arrayBuffer())
    .then(buf => audioSb.appendBuffer(buf))
  
  // 4. 结束流
  mediaSource.endOfStream()
})
```

**推荐方案：**
- **快速开发**：`dash.js`（成熟库，支持完整 DASH）
- **学习/定制**：自研 MSE 播放器（你现在的实现方向）

---

## 三、完整技术栈清单

### 3.1 后端技术栈

| 分类 | 技术 | 用途 |
|------|------|------|
| **Web 框架** | Spring Boot 3.x | REST API、任务调度 |
| **数据库** | MySQL / PostgreSQL | 视频元数据、任务队列 |
| **缓存** | Redis | 任务队列、播放清单缓存 |
| **消息队列** | RabbitMQ / Redis Queue | 转码任务队列 |
| **文件处理** | FFmpeg（命令行） | 视频转码、分片 |
| **元数据提取** | ffprobe / Java MediaInfo | 视频信息提取 |
| **对象存储 SDK** | 阿里云 OSS SDK / AWS S3 SDK | 云存储操作 |
| **HTTP 客户端** | OkHttp / Apache HttpClient | 调用云存储 API |

### 3.2 前端技术栈

| 分类 | 技术 | 用途 |
|------|------|------|
| **框架** | Vue 3 + Vite | 前端应用 |
| **HTTP 请求** | axios | API 调用 |
| **播放器核心** | Media Source Extensions (MSE) | 分片播放 |
| **播放器库（可选）** | dash.js / hls.js | 成熟 DASH/HLS 播放器 |
| **状态管理** | Pinia | 全局状态 |
| **路由** | Vue Router | 页面路由 |

### 3.3 基础设施

| 分类 | 技术 | 用途 |
|------|------|------|
| **容器化** | Docker / Kubernetes | 转码服务容器化 |
| **反向代理** | Nginx | 静态文件服务、CDN |
| **CDN** | 阿里云 CDN / CloudFlare | 分片文件加速 |
| **监控** | Prometheus + Grafana | 转码任务监控 |

---

## 四、核心流程详解

### 4.1 上传流程

```
1. 前端选择文件 → 2. 计算 MD5 → 3. 调用上传接口 → 4. 后端返回上传 URL（云存储）或直接写入本地
5. 前端分块上传（multipart）→ 6. 上传完成 → 7. 后端创建转码任务 → 8. 返回 videoId
```

**技术点：**
- 前端：`FormData` + `axios.post` + `onUploadProgress`
- 后端：接收文件 → 写入存储 → 创建任务记录

---

### 4.2 转码流程

```
1. 任务队列消费 → 2. 从存储读取源文件 → 3. FFmpeg 多清晰度转码（并行）
4. 生成 fMP4 分片 → 5. 上传分片到存储 → 6. 生成 manifest.json
7. 更新数据库（状态=DONE）→ 8. 通知前端（WebSocket/轮询）
```

**技术点：**
- FFmpeg 多进程并行转码
- 分片命名规范：`seg-{清晰度}-{序号}.m4s`
- Manifest 自动生成（根据实际分片文件）

---

### 4.3 播放流程

```
1. 前端请求 /api/playurl/{cid} → 2. 后端返回 manifest.json
3. 前端 MSE 创建 MediaSource + SourceBuffer
4. 根据 manifest 的 baseUrl 列表 fetch 分片
5. appendBuffer 到 SourceBuffer → 6. video.play()
7. 监听 timeupdate → 8. 预加载下一个分片
9. 清晰度切换 → 10. 切换 video 轨 baseUrl → 11. 重新 append
```

**技术点：**
- MSE `addSourceBuffer` + `appendBuffer`
- 音视频同步（时间戳对齐）
- 分片预加载策略（提前 3-5 个分片）

---

## 五、多清晰度配置标准

| 清晰度 ID | 分辨率 | 视频码率 | 音频码率 | 用途 |
|----------|--------|---------|---------|------|
| 16 | 640x360 | 500 kbps | 64 kbps | 流畅（移动端） |
| 32 | 854x480 | 1 Mbps | 96 kbps | 标清 |
| 64 | 1280x720 | 2 Mbps | 128 kbps | 准高清 |
| 80 | 1920x1080 | 4 Mbps | 192 kbps | 高清 |
| 112 | 1920x1080 | 6 Mbps | 256 kbps | 高码率 |

**FFmpeg 转码参数示例：**
```bash
# 720P 转码
ffmpeg -i input.mp4 \
  -c:v libx264 -preset medium -crf 23 \
  -maxrate 2M -bufsize 4M \
  -s 1280x720 -r 30 \
  -c:a aac -b:a 128k \
  output_720p.mp4
```

---

## 六、存储方案对比

### 6.1 云存储方案

**优点：**
- 自动 CDN 分发
- 高可用、自动备份
- 按需付费

**缺点：**
- 需要网络带宽
- 成本随流量增长

**适用场景：** 生产环境、公网访问

---

### 6.2 本地存储方案（E盘）

**优点：**
- 无流量成本
- 访问速度快（本地）
- 完全可控

**缺点：**
- 需要自己管理备份
- 单点故障风险

**适用场景：** 开发环境、内网部署、个人项目

**实现方式：**
- Spring Boot 静态资源映射：`/mse/**` → `E:\VideoHubStorage\**`
- Nginx 静态文件服务：`location /mse/ { alias E:/VideoHubStorage/; }`

---

## 七、推荐的技术选型（按规模）

### 7.1 小型项目（个人/学习）

- **后端**：Spring Boot + FFmpeg（命令行）+ MySQL
- **存储**：本地 E盘 + Spring Boot 静态资源
- **前端**：Vue 3 + 自研 MSE 播放器
- **转码**：同步转码（用户等待）或简单异步任务

---

### 7.2 中型项目（团队/产品）

- **后端**：Spring Boot + FFmpeg + Redis Queue + MySQL
- **存储**：云存储（OSS/COS）+ CDN
- **前端**：Vue 3 + dash.js
- **转码**：异步任务队列 + 多进程并行

---

### 7.3 大型项目（企业级）

- **后端**：微服务架构 + Kubernetes Jobs
- **转码**：FFmpeg 集群 + 分布式任务调度
- **存储**：对象存储 + CDN + 多地域备份
- **播放**：dash.js + 自适应码率（ABR）

---

## 八、关键技术文档参考

1. **DASH 标准**：ISO/IEC 23009-1（MPEG-DASH）
2. **MSE API**：MDN Media Source Extensions
3. **FFmpeg 文档**：https://ffmpeg.org/documentation.html
4. **dash.js**：https://github.com/Dash-Industry-Forum/dash.js

---

## 九、总结

**核心思想：**
- **存储**：多清晰度、多轨道、分片存储（fMP4）
- **播放**：MSE + DASH manifest + 按需加载分片
- **流程**：上传 → 转码 → 分片 → manifest → 播放

**你现在的项目已经具备：**
- ✅ 后端 playurl 接口（简化版）
- ✅ 前端 MSE 播放器（基础版）
- ✅ 分片文件样本（B站下载的 .m4s）

**下一步可以完善：**
- 🔄 多清晰度转码流程
- 🔄 完整的 manifest 生成
- 🔄 多分片顺序播放（而非单个 m4s）
- 🔄 清晰度切换 UI







